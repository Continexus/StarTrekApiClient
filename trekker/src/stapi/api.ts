/* tslint:disable */
/* eslint-disable */
/**
 * STAPI
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * Base animal, returned in search results
 * @export
 * @interface AnimalBase
 */
export interface AnimalBase {
    /**
     * Animal unique ID
     * @type {string}
     * @memberof AnimalBase
     */
    'uid'?: string;
    /**
     * Animal name
     * @type {string}
     * @memberof AnimalBase
     */
    'name'?: string;
    /**
     * Whether it\'s an earth animal
     * @type {boolean}
     * @memberof AnimalBase
     */
    'earthAnimal'?: boolean;
    /**
     * Whether it\'s an earth insect
     * @type {boolean}
     * @memberof AnimalBase
     */
    'earthInsect'?: boolean;
    /**
     * Whether it\'s an avian
     * @type {boolean}
     * @memberof AnimalBase
     */
    'avian'?: boolean;
    /**
     * Whether it\'s a canine
     * @type {boolean}
     * @memberof AnimalBase
     */
    'canine'?: boolean;
    /**
     * Whether it\'s a feline
     * @type {boolean}
     * @memberof AnimalBase
     */
    'feline'?: boolean;
}
/**
 * Response object for animals search
 * @export
 * @interface AnimalBaseResponse
 */
export interface AnimalBaseResponse {
    /**
     * 
     * @type {ResponsePage}
     * @memberof AnimalBaseResponse
     */
    'page'?: ResponsePage;
    /**
     * 
     * @type {ResponseSort}
     * @memberof AnimalBaseResponse
     */
    'sort'?: ResponseSort;
    /**
     * List of animals matching given criteria
     * @type {Array<AnimalBase>}
     * @memberof AnimalBaseResponse
     */
    'animals'?: Array<AnimalBase>;
}
/**
 * Full animal, returned when queried using UID
 * @export
 * @interface AnimalFull
 */
export interface AnimalFull {
    /**
     * Animal unique ID
     * @type {string}
     * @memberof AnimalFull
     */
    'uid'?: string;
    /**
     * Animal name
     * @type {string}
     * @memberof AnimalFull
     */
    'name'?: string;
    /**
     * Whether it\'s an earth animal
     * @type {boolean}
     * @memberof AnimalFull
     */
    'earthAnimal'?: boolean;
    /**
     * Whether it\'s an earth insect
     * @type {boolean}
     * @memberof AnimalFull
     */
    'earthInsect'?: boolean;
    /**
     * Whether it\'s an avian
     * @type {boolean}
     * @memberof AnimalFull
     */
    'avian'?: boolean;
    /**
     * Whether it\'s a canine
     * @type {boolean}
     * @memberof AnimalFull
     */
    'canine'?: boolean;
    /**
     * Whether it\'s a feline
     * @type {boolean}
     * @memberof AnimalFull
     */
    'feline'?: boolean;
}
/**
 * Response object for single animal query
 * @export
 * @interface AnimalFullResponse
 */
export interface AnimalFullResponse {
    /**
     * 
     * @type {AnimalFull}
     * @memberof AnimalFullResponse
     */
    'animal'?: AnimalFull;
}
/**
 * Header animal, embedded in other objects
 * @export
 * @interface AnimalHeader
 */
export interface AnimalHeader {
    /**
     * Animal unique ID
     * @type {string}
     * @memberof AnimalHeader
     */
    'uid'?: string;
    /**
     * Animal name
     * @type {string}
     * @memberof AnimalHeader
     */
    'name'?: string;
}
/**
 * Base astronomical object, returned in search results
 * @export
 * @interface AstronomicalObjectBase
 */
export interface AstronomicalObjectBase {
    /**
     * Astronomical object\'s unique ID
     * @type {string}
     * @memberof AstronomicalObjectBase
     */
    'uid'?: string;
    /**
     * Astronomical object name
     * @type {string}
     * @memberof AstronomicalObjectBase
     */
    'name'?: string;
    /**
     * 
     * @type {AstronomicalObjectType}
     * @memberof AstronomicalObjectBase
     */
    'astronomicalObjectType'?: AstronomicalObjectType;
    /**
     * 
     * @type {AstronomicalObjectHeader}
     * @memberof AstronomicalObjectBase
     */
    'location'?: AstronomicalObjectHeader;
}
/**
 * Response object for astronomical objects search
 * @export
 * @interface AstronomicalObjectBaseResponse
 */
export interface AstronomicalObjectBaseResponse {
    /**
     * 
     * @type {ResponsePage}
     * @memberof AstronomicalObjectBaseResponse
     */
    'page'?: ResponsePage;
    /**
     * 
     * @type {ResponseSort}
     * @memberof AstronomicalObjectBaseResponse
     */
    'sort'?: ResponseSort;
    /**
     * List of astronomical objects matching given criteria
     * @type {Array<AstronomicalObjectBase>}
     * @memberof AstronomicalObjectBaseResponse
     */
    'astronomicalObjects'?: Array<AstronomicalObjectBase>;
}
/**
 * Full astronomical object, returned when queried using UID
 * @export
 * @interface AstronomicalObjectFull
 */
export interface AstronomicalObjectFull {
    /**
     * Astronomical object\'s unique ID
     * @type {string}
     * @memberof AstronomicalObjectFull
     */
    'uid'?: string;
    /**
     * Astronomical object name
     * @type {string}
     * @memberof AstronomicalObjectFull
     */
    'name'?: string;
    /**
     * 
     * @type {AstronomicalObjectType}
     * @memberof AstronomicalObjectFull
     */
    'astronomicalObjectType'?: AstronomicalObjectType;
    /**
     * 
     * @type {AstronomicalObjectBase}
     * @memberof AstronomicalObjectFull
     */
    'location'?: AstronomicalObjectBase;
    /**
     * Astronomical objects located in this astronomical object, like planets in a star system
     * @type {Array<AstronomicalObjectBase>}
     * @memberof AstronomicalObjectFull
     */
    'astronomicalObjects'?: Array<AstronomicalObjectBase>;
}
/**
 * Response object for single astronomical object query
 * @export
 * @interface AstronomicalObjectFullResponse
 */
export interface AstronomicalObjectFullResponse {
    /**
     * 
     * @type {AstronomicalObjectFull}
     * @memberof AstronomicalObjectFullResponse
     */
    'astronomicalObject'?: AstronomicalObjectFull;
}
/**
 * Header astronomical object, embedded in other objects
 * @export
 * @interface AstronomicalObjectHeader
 */
export interface AstronomicalObjectHeader {
    /**
     * Astronomical object\'s unique ID
     * @type {string}
     * @memberof AstronomicalObjectHeader
     */
    'uid'?: string;
    /**
     * Astronomical object name
     * @type {string}
     * @memberof AstronomicalObjectHeader
     */
    'name'?: string;
}
/**
 * Astronomical object type
 * @export
 * @enum {string}
 */

export enum AstronomicalObjectType {
    Planet = 'PLANET',
    DClassPlanet = 'D_CLASS_PLANET',
    HClassPlanet = 'H_CLASS_PLANET',
    GasGiantPlanet = 'GAS_GIANT_PLANET',
    KClassPlanet = 'K_CLASS_PLANET',
    LClassPlanet = 'L_CLASS_PLANET',
    MClassPlanet = 'M_CLASS_PLANET',
    YClassPlanet = 'Y_CLASS_PLANET',
    RoguePlanet = 'ROGUE_PLANET',
    ArtificialPlanet = 'ARTIFICIAL_PLANET',
    Asteroid = 'ASTEROID',
    AsteroidalMoon = 'ASTEROIDAL_MOON',
    AsteroidBelt = 'ASTEROID_BELT',
    Cluster = 'CLUSTER',
    Comet = 'COMET',
    Constellation = 'CONSTELLATION',
    Galaxy = 'GALAXY',
    Moon = 'MOON',
    MClassMoon = 'M_CLASS_MOON',
    Nebula = 'NEBULA',
    Planetoid = 'PLANETOID',
    DClassPlanetoid = 'D_CLASS_PLANETOID',
    Quasar = 'QUASAR',
    Star = 'STAR',
    StarSystem = 'STAR_SYSTEM',
    Sector = 'SECTOR',
    Region = 'REGION'
}

/**
 * Blood type
 * @export
 * @enum {string}
 */

export enum BloodType {
    BNegative = 'B_NEGATIVE',
    ONegative = 'O_NEGATIVE',
    TNegative = 'T_NEGATIVE'
}

/**
 * Base book, returned in search results
 * @export
 * @interface BookBase
 */
export interface BookBase {
    /**
     * Book unique ID
     * @type {string}
     * @memberof BookBase
     */
    'uid'?: string;
    /**
     * Book title
     * @type {string}
     * @memberof BookBase
     */
    'title'?: string;
    /**
     * Year the book was published
     * @type {number}
     * @memberof BookBase
     */
    'publishedYear'?: number;
    /**
     * Month the book was published
     * @type {number}
     * @memberof BookBase
     */
    'publishedMonth'?: number;
    /**
     * Day the book was published
     * @type {number}
     * @memberof BookBase
     */
    'publishedDay'?: number;
    /**
     * Number of pages
     * @type {number}
     * @memberof BookBase
     */
    'numberOfPages'?: number;
    /**
     * Starting stardate of book story
     * @type {number}
     * @memberof BookBase
     */
    'stardateFrom'?: number;
    /**
     * Ending stardate of book story
     * @type {number}
     * @memberof BookBase
     */
    'stardateTo'?: number;
    /**
     * Starting year of book story
     * @type {number}
     * @memberof BookBase
     */
    'yearFrom'?: number;
    /**
     * Ending year of book story
     * @type {number}
     * @memberof BookBase
     */
    'yearTo'?: number;
    /**
     * Whether it\'s a novel
     * @type {boolean}
     * @memberof BookBase
     */
    'novel'?: boolean;
    /**
     * Whether it\'s a reference book
     * @type {boolean}
     * @memberof BookBase
     */
    'referenceBook'?: boolean;
    /**
     * Whether it\'s a biography book
     * @type {boolean}
     * @memberof BookBase
     */
    'biographyBook'?: boolean;
    /**
     * Whether it\'s a role playing book
     * @type {boolean}
     * @memberof BookBase
     */
    'rolePlayingBook'?: boolean;
    /**
     * Whether it\'s an eBook
     * @type {boolean}
     * @memberof BookBase
     */
    'eBook'?: boolean;
    /**
     * Whether it\'s an anthology
     * @type {boolean}
     * @memberof BookBase
     */
    'anthology'?: boolean;
    /**
     * Whether it\'s a novelization
     * @type {boolean}
     * @memberof BookBase
     */
    'novelization'?: boolean;
    /**
     * Whether it\'s an audiobook, or has been release as an audiobook in addition to other form
     * @type {boolean}
     * @memberof BookBase
     */
    'audiobook'?: boolean;
    /**
     * If it\'s an audiobook, whether it\'s been abridged
     * @type {boolean}
     * @memberof BookBase
     */
    'audiobookAbridged'?: boolean;
    /**
     * Year the audiobook was published
     * @type {number}
     * @memberof BookBase
     */
    'audiobookPublishedYear'?: number;
    /**
     * Month the audiobook was published
     * @type {number}
     * @memberof BookBase
     */
    'audiobookPublishedMonth'?: number;
    /**
     * Day the audiobook was published
     * @type {number}
     * @memberof BookBase
     */
    'audiobookPublishedDay'?: number;
    /**
     * Audiobook run time, in minutes
     * @type {number}
     * @memberof BookBase
     */
    'audiobookRunTime'?: number;
    /**
     * Book\'s production number
     * @type {string}
     * @memberof BookBase
     */
    'productionNumber'?: string;
}
/**
 * Response object for books search
 * @export
 * @interface BookBaseResponse
 */
export interface BookBaseResponse {
    /**
     * 
     * @type {ResponsePage}
     * @memberof BookBaseResponse
     */
    'page'?: ResponsePage;
    /**
     * 
     * @type {ResponseSort}
     * @memberof BookBaseResponse
     */
    'sort'?: ResponseSort;
    /**
     * List of books matching given criteria
     * @type {Array<BookBase>}
     * @memberof BookBaseResponse
     */
    'books'?: Array<BookBase>;
}
/**
 * Base book collection, returned in search results
 * @export
 * @interface BookCollectionBase
 */
export interface BookCollectionBase {
    /**
     * Book collection unique ID
     * @type {string}
     * @memberof BookCollectionBase
     */
    'uid'?: string;
    /**
     * Book collection title
     * @type {string}
     * @memberof BookCollectionBase
     */
    'title'?: string;
    /**
     * Year the book collection was published
     * @type {number}
     * @memberof BookCollectionBase
     */
    'publishedYear'?: number;
    /**
     * Month the book collection was published
     * @type {number}
     * @memberof BookCollectionBase
     */
    'publishedMonth'?: number;
    /**
     * Day the book collection was published
     * @type {number}
     * @memberof BookCollectionBase
     */
    'publishedDay'?: number;
    /**
     * Number of pages
     * @type {number}
     * @memberof BookCollectionBase
     */
    'numberOfPages'?: number;
    /**
     * Starting stardate of book collection stories
     * @type {number}
     * @memberof BookCollectionBase
     */
    'stardateFrom'?: number;
    /**
     * Ending stardate of book collection stories
     * @type {number}
     * @memberof BookCollectionBase
     */
    'stardateTo'?: number;
    /**
     * Starting year of book collection stories
     * @type {number}
     * @memberof BookCollectionBase
     */
    'yearFrom'?: number;
    /**
     * Ending year of book collection stories
     * @type {number}
     * @memberof BookCollectionBase
     */
    'yearTo'?: number;
}
/**
 * Response object for book collections search
 * @export
 * @interface BookCollectionBaseResponse
 */
export interface BookCollectionBaseResponse {
    /**
     * 
     * @type {ResponsePage}
     * @memberof BookCollectionBaseResponse
     */
    'page'?: ResponsePage;
    /**
     * 
     * @type {ResponseSort}
     * @memberof BookCollectionBaseResponse
     */
    'sort'?: ResponseSort;
    /**
     * List of book collections matching given criteria
     * @type {Array<BookCollectionBase>}
     * @memberof BookCollectionBaseResponse
     */
    'bookCollections'?: Array<BookCollectionBase>;
}
/**
 * Full book collection, returned when queried using UID
 * @export
 * @interface BookCollectionFull
 */
export interface BookCollectionFull {
    /**
     * Book collection unique ID
     * @type {string}
     * @memberof BookCollectionFull
     */
    'uid'?: string;
    /**
     * Book collection title
     * @type {string}
     * @memberof BookCollectionFull
     */
    'title'?: string;
    /**
     * Year the book collection was published
     * @type {number}
     * @memberof BookCollectionFull
     */
    'publishedYear'?: number;
    /**
     * Month the book collection was published
     * @type {number}
     * @memberof BookCollectionFull
     */
    'publishedMonth'?: number;
    /**
     * Day the book collection was published
     * @type {number}
     * @memberof BookCollectionFull
     */
    'publishedDay'?: number;
    /**
     * Number of pages
     * @type {number}
     * @memberof BookCollectionFull
     */
    'numberOfPages'?: number;
    /**
     * Starting stardate of book collection stories
     * @type {number}
     * @memberof BookCollectionFull
     */
    'stardateFrom'?: number;
    /**
     * Ending stardate of book collection stories
     * @type {number}
     * @memberof BookCollectionFull
     */
    'stardateTo'?: number;
    /**
     * Starting year of book collection stories
     * @type {number}
     * @memberof BookCollectionFull
     */
    'yearFrom'?: number;
    /**
     * Ending year of book collection stories
     * @type {number}
     * @memberof BookCollectionFull
     */
    'yearTo'?: number;
    /**
     * Book series this book collection is included in
     * @type {Array<BookSeriesBase>}
     * @memberof BookCollectionFull
     */
    'bookSeries'?: Array<BookSeriesBase>;
    /**
     * Authors of the book collection
     * @type {Array<StaffBase>}
     * @memberof BookCollectionFull
     */
    'authors'?: Array<StaffBase>;
    /**
     * Artists involved in the book collection
     * @type {Array<StaffBase>}
     * @memberof BookCollectionFull
     */
    'artists'?: Array<StaffBase>;
    /**
     * Editors involved in the book collection
     * @type {Array<StaffBase>}
     * @memberof BookCollectionFull
     */
    'editors'?: Array<StaffBase>;
    /**
     * Book collection publishers
     * @type {Array<CompanyBase>}
     * @memberof BookCollectionFull
     */
    'publishers'?: Array<CompanyBase>;
    /**
     * Characters appearing in the book collection
     * @type {Array<CharacterBase>}
     * @memberof BookCollectionFull
     */
    'characters'?: Array<CharacterBase>;
    /**
     * References
     * @type {Array<Reference>}
     * @memberof BookCollectionFull
     */
    'references'?: Array<Reference>;
    /**
     * Books included in this book collection
     * @type {Array<BookBase>}
     * @memberof BookCollectionFull
     */
    'books'?: Array<BookBase>;
}
/**
 * Response object for single book collection query
 * @export
 * @interface BookCollectionFullResponse
 */
export interface BookCollectionFullResponse {
    /**
     * 
     * @type {BookCollectionFull}
     * @memberof BookCollectionFullResponse
     */
    'bookCollection'?: BookCollectionFull;
}
/**
 * Header book collection, embedded in other objects
 * @export
 * @interface BookCollectionHeader
 */
export interface BookCollectionHeader {
    /**
     * Book collection unique ID
     * @type {string}
     * @memberof BookCollectionHeader
     */
    'uid'?: string;
    /**
     * Book collection title
     * @type {string}
     * @memberof BookCollectionHeader
     */
    'title'?: string;
}
/**
 * Full book, returned when queried using UID
 * @export
 * @interface BookFull
 */
export interface BookFull {
    /**
     * Book unique ID
     * @type {string}
     * @memberof BookFull
     */
    'uid'?: string;
    /**
     * Book title
     * @type {string}
     * @memberof BookFull
     */
    'title'?: string;
    /**
     * Year the book was published
     * @type {number}
     * @memberof BookFull
     */
    'publishedYear'?: number;
    /**
     * Month the book was published
     * @type {number}
     * @memberof BookFull
     */
    'publishedMonth'?: number;
    /**
     * Day the book was published
     * @type {number}
     * @memberof BookFull
     */
    'publishedDay'?: number;
    /**
     * Number of pages
     * @type {number}
     * @memberof BookFull
     */
    'numberOfPages'?: number;
    /**
     * Starting stardate of book story
     * @type {number}
     * @memberof BookFull
     */
    'stardateFrom'?: number;
    /**
     * Ending stardate of book story
     * @type {number}
     * @memberof BookFull
     */
    'stardateTo'?: number;
    /**
     * Starting year of book story
     * @type {number}
     * @memberof BookFull
     */
    'yearFrom'?: number;
    /**
     * Ending year of book story
     * @type {number}
     * @memberof BookFull
     */
    'yearTo'?: number;
    /**
     * Whether it\'s a novel
     * @type {boolean}
     * @memberof BookFull
     */
    'novel'?: boolean;
    /**
     * Whether it\'s a reference book
     * @type {boolean}
     * @memberof BookFull
     */
    'referenceBook'?: boolean;
    /**
     * Whether it\'s a biography book
     * @type {boolean}
     * @memberof BookFull
     */
    'biographyBook'?: boolean;
    /**
     * Whether it\'s a role playing book
     * @type {boolean}
     * @memberof BookFull
     */
    'rolePlayingBook'?: boolean;
    /**
     * Whether it\'s an e-book
     * @type {boolean}
     * @memberof BookFull
     */
    'eBook'?: boolean;
    /**
     * Whether it\'s an anthology
     * @type {boolean}
     * @memberof BookFull
     */
    'anthology'?: boolean;
    /**
     * Whether it\'s a novelization
     * @type {boolean}
     * @memberof BookFull
     */
    'novelization'?: boolean;
    /**
     * Whether it\'s an audiobook, or has been release as an audiobook in addition to other form
     * @type {boolean}
     * @memberof BookFull
     */
    'audiobook'?: boolean;
    /**
     * If it\'s an audiobook, whether it\'s been abridged
     * @type {boolean}
     * @memberof BookFull
     */
    'audiobookAbridged'?: boolean;
    /**
     * Year the audiobook was published
     * @type {number}
     * @memberof BookFull
     */
    'audiobookPublishedYear'?: number;
    /**
     * Month the audiobook was published
     * @type {number}
     * @memberof BookFull
     */
    'audiobookPublishedMonth'?: number;
    /**
     * Day the audiobook was published
     * @type {number}
     * @memberof BookFull
     */
    'audiobookPublishedDay'?: number;
    /**
     * Audiobook run time, in minutes
     * @type {number}
     * @memberof BookFull
     */
    'audiobookRunTime'?: number;
    /**
     * Book production number
     * @type {string}
     * @memberof BookFull
     */
    'productionNumber'?: string;
    /**
     * Book series this book is included in
     * @type {Array<BookSeriesBase>}
     * @memberof BookFull
     */
    'bookSeries'?: Array<BookSeriesBase>;
    /**
     * Authors of the book
     * @type {Array<StaffBase>}
     * @memberof BookFull
     */
    'authors'?: Array<StaffBase>;
    /**
     * Artists involved in the book
     * @type {Array<StaffBase>}
     * @memberof BookFull
     */
    'artists'?: Array<StaffBase>;
    /**
     * Editors involved in the book
     * @type {Array<StaffBase>}
     * @memberof BookFull
     */
    'editors'?: Array<StaffBase>;
    /**
     * Audiobook narrators
     * @type {Array<StaffBase>}
     * @memberof BookFull
     */
    'audiobookNarrators'?: Array<StaffBase>;
    /**
     * Book publishers
     * @type {Array<CompanyBase>}
     * @memberof BookFull
     */
    'publishers'?: Array<CompanyBase>;
    /**
     * Audiobook publishers
     * @type {Array<CompanyBase>}
     * @memberof BookFull
     */
    'audiobookPublishers'?: Array<CompanyBase>;
    /**
     * Characters appearing the book
     * @type {Array<CharacterBase>}
     * @memberof BookFull
     */
    'characters'?: Array<CharacterBase>;
    /**
     * References
     * @type {Array<Reference>}
     * @memberof BookFull
     */
    'references'?: Array<Reference>;
    /**
     * Audiobook references
     * @type {Array<Reference>}
     * @memberof BookFull
     */
    'audiobookReferences'?: Array<Reference>;
    /**
     * Book collections this book is included in
     * @type {Array<BookCollectionBase>}
     * @memberof BookFull
     */
    'bookCollections'?: Array<BookCollectionBase>;
}
/**
 * Response object for single book query
 * @export
 * @interface BookFullResponse
 */
export interface BookFullResponse {
    /**
     * 
     * @type {BookFull}
     * @memberof BookFullResponse
     */
    'book'?: BookFull;
}
/**
 * Header book, embedded in other objects
 * @export
 * @interface BookHeader
 */
export interface BookHeader {
    /**
     * Book unique ID
     * @type {string}
     * @memberof BookHeader
     */
    'uid'?: string;
    /**
     * Book title
     * @type {string}
     * @memberof BookHeader
     */
    'title'?: string;
}
/**
 * Base book series, returned in search results
 * @export
 * @interface BookSeriesBase
 */
export interface BookSeriesBase {
    /**
     * Book series unique ID
     * @type {string}
     * @memberof BookSeriesBase
     */
    'uid'?: string;
    /**
     * Book series title
     * @type {string}
     * @memberof BookSeriesBase
     */
    'title'?: string;
    /**
     * Year from which the book series was published
     * @type {number}
     * @memberof BookSeriesBase
     */
    'publishedYearFrom'?: number;
    /**
     * Month from which the book series was published
     * @type {number}
     * @memberof BookSeriesBase
     */
    'publishedMonthFrom'?: number;
    /**
     * Year to which the book series was published
     * @type {number}
     * @memberof BookSeriesBase
     */
    'publishedYearTo'?: number;
    /**
     * Month to which the book series was published
     * @type {number}
     * @memberof BookSeriesBase
     */
    'publishedMonthTo'?: number;
    /**
     * Number of pages
     * @type {number}
     * @memberof BookSeriesBase
     */
    'numberOfBooks'?: number;
    /**
     * Starting year of book series stories
     * @type {number}
     * @memberof BookSeriesBase
     */
    'yearFrom'?: number;
    /**
     * Ending year of book series stories
     * @type {number}
     * @memberof BookSeriesBase
     */
    'yearTo'?: number;
    /**
     * Whether it\'s a miniseries
     * @type {boolean}
     * @memberof BookSeriesBase
     */
    'miniseries'?: boolean;
    /**
     * Whether it\'s a e-book series
     * @type {boolean}
     * @memberof BookSeriesBase
     */
    'eBookSeries'?: boolean;
}
/**
 * Response object for book series search
 * @export
 * @interface BookSeriesBaseResponse
 */
export interface BookSeriesBaseResponse {
    /**
     * 
     * @type {ResponsePage}
     * @memberof BookSeriesBaseResponse
     */
    'page'?: ResponsePage;
    /**
     * 
     * @type {ResponseSort}
     * @memberof BookSeriesBaseResponse
     */
    'sort'?: ResponseSort;
    /**
     * List of book series matching given criteria
     * @type {Array<BookSeriesBase>}
     * @memberof BookSeriesBaseResponse
     */
    'bookSeries'?: Array<BookSeriesBase>;
}
/**
 * Full book series, returned when queried using UID
 * @export
 * @interface BookSeriesFull
 */
export interface BookSeriesFull {
    /**
     * Book series unique ID
     * @type {string}
     * @memberof BookSeriesFull
     */
    'uid'?: string;
    /**
     * Book series title
     * @type {string}
     * @memberof BookSeriesFull
     */
    'title'?: string;
    /**
     * Year from which the book series was published
     * @type {number}
     * @memberof BookSeriesFull
     */
    'publishedYearFrom'?: number;
    /**
     * Month from which the book series was published
     * @type {number}
     * @memberof BookSeriesFull
     */
    'publishedMonthFrom'?: number;
    /**
     * Year to which the book series was published
     * @type {number}
     * @memberof BookSeriesFull
     */
    'publishedYearTo'?: number;
    /**
     * Month to which the book series was published
     * @type {number}
     * @memberof BookSeriesFull
     */
    'publishedMonthTo'?: number;
    /**
     * Number of books in book series
     * @type {number}
     * @memberof BookSeriesFull
     */
    'numberOfBooks'?: number;
    /**
     * Starting year of book series stories
     * @type {number}
     * @memberof BookSeriesFull
     */
    'yearFrom'?: number;
    /**
     * Ending year of book series stories
     * @type {number}
     * @memberof BookSeriesFull
     */
    'yearTo'?: number;
    /**
     * Whether it\'s a miniseries
     * @type {boolean}
     * @memberof BookSeriesFull
     */
    'miniseries'?: boolean;
    /**
     * Whether it\'s a e-book series
     * @type {boolean}
     * @memberof BookSeriesFull
     */
    'eBookSeries'?: boolean;
    /**
     * Book series this book series is included in
     * @type {Array<BookSeriesBase>}
     * @memberof BookSeriesFull
     */
    'parentSeries'?: Array<BookSeriesBase>;
    /**
     * Child book series included in this book series
     * @type {Array<BookSeriesBase>}
     * @memberof BookSeriesFull
     */
    'childSeries'?: Array<BookSeriesBase>;
    /**
     * Companies that published this book series
     * @type {Array<CompanyBase>}
     * @memberof BookSeriesFull
     */
    'publishers'?: Array<CompanyBase>;
    /**
     * Books included in this book series
     * @type {Array<BookBase>}
     * @memberof BookSeriesFull
     */
    'books'?: Array<BookBase>;
}
/**
 * Response object for single book series query
 * @export
 * @interface BookSeriesFullResponse
 */
export interface BookSeriesFullResponse {
    /**
     * 
     * @type {BookSeriesFull}
     * @memberof BookSeriesFullResponse
     */
    'bookSeries'?: BookSeriesFull;
}
/**
 * Header book series, embedded in other objects
 * @export
 * @interface BookSeriesHeader
 */
export interface BookSeriesHeader {
    /**
     * Book series unique ID
     * @type {string}
     * @memberof BookSeriesHeader
     */
    'uid'?: string;
    /**
     * Book series title
     * @type {string}
     * @memberof BookSeriesHeader
     */
    'title'?: string;
}
/**
 * Base character, returned in search results
 * @export
 * @interface CharacterBase
 */
export interface CharacterBase {
    /**
     * Character unique ID
     * @type {string}
     * @memberof CharacterBase
     */
    'uid'?: string;
    /**
     * Character name
     * @type {string}
     * @memberof CharacterBase
     */
    'name'?: string;
    /**
     * 
     * @type {Gender}
     * @memberof CharacterBase
     */
    'gender'?: Gender;
    /**
     * Year the character was born
     * @type {number}
     * @memberof CharacterBase
     */
    'yearOfBirth'?: number;
    /**
     * Month the character was born
     * @type {number}
     * @memberof CharacterBase
     */
    'monthOfBirth'?: number;
    /**
     * Day the character was born
     * @type {number}
     * @memberof CharacterBase
     */
    'dayOfBirth'?: number;
    /**
     * Place of birth
     * @type {string}
     * @memberof CharacterBase
     */
    'placeOfBirth'?: string;
    /**
     * Year the character died
     * @type {number}
     * @memberof CharacterBase
     */
    'yearOfDeath'?: number;
    /**
     * Month the character died
     * @type {number}
     * @memberof CharacterBase
     */
    'monthOfDeath'?: number;
    /**
     * Day the character died
     * @type {number}
     * @memberof CharacterBase
     */
    'dayOfDeath'?: number;
    /**
     * Place of death
     * @type {string}
     * @memberof CharacterBase
     */
    'placeOfDeath'?: string;
    /**
     * Height in centimeters
     * @type {number}
     * @memberof CharacterBase
     */
    'height'?: number;
    /**
     * Weight in kilograms
     * @type {number}
     * @memberof CharacterBase
     */
    'weight'?: number;
    /**
     * Whether this character is deceased
     * @type {boolean}
     * @memberof CharacterBase
     */
    'deceased'?: boolean;
    /**
     * 
     * @type {BloodType}
     * @memberof CharacterBase
     */
    'bloodType'?: BloodType;
    /**
     * 
     * @type {MaritalStatus}
     * @memberof CharacterBase
     */
    'maritalStatus'?: MaritalStatus;
    /**
     * Serial number
     * @type {string}
     * @memberof CharacterBase
     */
    'serialNumber'?: string;
    /**
     * Hologram activation date
     * @type {string}
     * @memberof CharacterBase
     */
    'hologramActivationDate'?: string;
    /**
     * Hologram status
     * @type {string}
     * @memberof CharacterBase
     */
    'hologramStatus'?: string;
    /**
     * Hologram date status
     * @type {string}
     * @memberof CharacterBase
     */
    'hologramDateStatus'?: string;
    /**
     * Whether this character is a hologram
     * @type {boolean}
     * @memberof CharacterBase
     */
    'hologram'?: boolean;
    /**
     * Whether this character is a fictional character (from universe point of view)
     * @type {boolean}
     * @memberof CharacterBase
     */
    'fictionalCharacter'?: boolean;
    /**
     * Whether this character is from mirror universe
     * @type {boolean}
     * @memberof CharacterBase
     */
    'mirror'?: boolean;
    /**
     * Whether this character is from alternate reality
     * @type {boolean}
     * @memberof CharacterBase
     */
    'alternateReality'?: boolean;
}
/**
 * Base company, returned in search results
 * @export
 * @interface CompanyBase
 */
export interface CompanyBase {
    /**
     * Company unique ID
     * @type {string}
     * @memberof CompanyBase
     */
    'uid'?: string;
    /**
     * Company name
     * @type {string}
     * @memberof CompanyBase
     */
    'name'?: string;
    /**
     * Whether it\'s a broadcaster
     * @type {boolean}
     * @memberof CompanyBase
     */
    'broadcaster'?: boolean;
    /**
     * Whether it\'s a collectible company
     * @type {boolean}
     * @memberof CompanyBase
     */
    'collectibleCompany'?: boolean;
    /**
     * Whether it\'s a conglomerate
     * @type {boolean}
     * @memberof CompanyBase
     */
    'conglomerate'?: boolean;
    /**
     * Whether it\'s a digital visual effects company
     * @type {boolean}
     * @memberof CompanyBase
     */
    'digitalVisualEffectsCompany'?: boolean;
    /**
     * Whether it\'s a distributor
     * @type {boolean}
     * @memberof CompanyBase
     */
    'distributor'?: boolean;
    /**
     * Whether it\'s a game company
     * @type {boolean}
     * @memberof CompanyBase
     */
    'gameCompany'?: boolean;
    /**
     * Whether it\'s a film equipment company
     * @type {boolean}
     * @memberof CompanyBase
     */
    'filmEquipmentCompany'?: boolean;
    /**
     * Whether it\'s a make-up effects studio
     * @type {boolean}
     * @memberof CompanyBase
     */
    'makeUpEffectsStudio'?: boolean;
    /**
     * Whether it\'s a matte painting company
     * @type {boolean}
     * @memberof CompanyBase
     */
    'mattePaintingCompany'?: boolean;
    /**
     * Whether it\'s a model and miniature effects company
     * @type {boolean}
     * @memberof CompanyBase
     */
    'modelAndMiniatureEffectsCompany'?: boolean;
    /**
     * Whether it\'s a post-production company
     * @type {boolean}
     * @memberof CompanyBase
     */
    'postProductionCompany'?: boolean;
    /**
     * Whether it\'s a production company
     * @type {boolean}
     * @memberof CompanyBase
     */
    'productionCompany'?: boolean;
    /**
     * Whether it\'s a prop company
     * @type {boolean}
     * @memberof CompanyBase
     */
    'propCompany'?: boolean;
    /**
     * Whether it\'s a record label
     * @type {boolean}
     * @memberof CompanyBase
     */
    'recordLabel'?: boolean;
    /**
     * Whether it\'s a special effects company
     * @type {boolean}
     * @memberof CompanyBase
     */
    'specialEffectsCompany'?: boolean;
    /**
     * Whether it\'s a TV and film production company
     * @type {boolean}
     * @memberof CompanyBase
     */
    'tvAndFilmProductionCompany'?: boolean;
    /**
     * Whether it\'s a video game company
     * @type {boolean}
     * @memberof CompanyBase
     */
    'videoGameCompany'?: boolean;
}
/**
 * Gender
 * @export
 * @enum {string}
 */

export enum Gender {
    F = 'F',
    M = 'M'
}

/**
 * Marital status
 * @export
 * @enum {string}
 */

export enum MaritalStatus {
    Single = 'SINGLE',
    Engaged = 'ENGAGED',
    Married = 'MARRIED',
    Divorced = 'DIVORCED',
    Remarried = 'REMARRIED',
    Separated = 'SEPARATED',
    Widowed = 'WIDOWED',
    CaptainsWoman = 'CAPTAINS_WOMAN'
}

/**
 * Error object
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * Error code
     * @type {string}
     * @memberof ModelError
     */
    'code'?: string;
    /**
     * Error message
     * @type {string}
     * @memberof ModelError
     */
    'message'?: string;
}
/**
 * Reference of book, comics, video release, etc.
 * @export
 * @interface Reference
 */
export interface Reference {
    /**
     * Reference unique ID
     * @type {string}
     * @memberof Reference
     */
    'uid'?: string;
    /**
     * 
     * @type {ReferenceType}
     * @memberof Reference
     */
    'referenceType'?: ReferenceType;
    /**
     * Reference number
     * @type {string}
     * @memberof Reference
     */
    'referenceNumber'?: string;
}
/**
 * Reference type
 * @export
 * @enum {string}
 */

export enum ReferenceType {
    Asin = 'ASIN',
    Isbn = 'ISBN'
}

/**
 * Object describing response page
 * @export
 * @interface ResponsePage
 */
export interface ResponsePage {
    /**
     * Zero-based page number
     * @type {number}
     * @memberof ResponsePage
     */
    'pageNumber'?: number;
    /**
     * Page size
     * @type {number}
     * @memberof ResponsePage
     */
    'pageSize'?: number;
    /**
     * Number of elements in page
     * @type {number}
     * @memberof ResponsePage
     */
    'numberOfElements'?: number;
    /**
     * Total elements found
     * @type {number}
     * @memberof ResponsePage
     */
    'totalElements'?: number;
    /**
     * Total pages found
     * @type {number}
     * @memberof ResponsePage
     */
    'totalPages'?: number;
    /**
     * Whether it is the first page
     * @type {boolean}
     * @memberof ResponsePage
     */
    'firstPage'?: boolean;
    /**
     * Whether it is the last page
     * @type {boolean}
     * @memberof ResponsePage
     */
    'lastPage'?: boolean;
}
/**
 * Response sort
 * @export
 * @interface ResponseSort
 */
export interface ResponseSort {
    /**
     * List of response sort rules
     * @type {Array<ResponseSortClause>}
     * @memberof ResponseSort
     */
    'clauses'?: Array<ResponseSortClause>;
}
/**
 * Single response sort clause
 * @export
 * @interface ResponseSortClause
 */
export interface ResponseSortClause {
    /**
     * Field name results are sorted by
     * @type {string}
     * @memberof ResponseSortClause
     */
    'name'?: string;
    /**
     * 
     * @type {ResponseSortDirection}
     * @memberof ResponseSortClause
     */
    'direction'?: ResponseSortDirection;
    /**
     * Order in which this clause was applied
     * @type {number}
     * @memberof ResponseSortClause
     */
    'clauseOrder'?: number;
}
/**
 * Sort direction
 * @export
 * @enum {string}
 */

export enum ResponseSortDirection {
    Asc = 'ASC',
    Desc = 'DESC'
}

/**
 * Base staff, returned in search results
 * @export
 * @interface StaffBase
 */
export interface StaffBase {
    /**
     * Staff unique ID
     * @type {string}
     * @memberof StaffBase
     */
    'uid'?: string;
    /**
     * Staff name
     * @type {string}
     * @memberof StaffBase
     */
    'name'?: string;
    /**
     * Staff birth name
     * @type {string}
     * @memberof StaffBase
     */
    'birthName'?: string;
    /**
     * 
     * @type {Gender}
     * @memberof StaffBase
     */
    'gender'?: Gender;
    /**
     * Date the staff was born
     * @type {string}
     * @memberof StaffBase
     */
    'dateOfBirth'?: string;
    /**
     * Place the staff was born
     * @type {string}
     * @memberof StaffBase
     */
    'placeOfBirth'?: string;
    /**
     * Date the staff died
     * @type {string}
     * @memberof StaffBase
     */
    'dateOfDeath'?: string;
    /**
     * Place the staff died
     * @type {string}
     * @memberof StaffBase
     */
    'placeOfDeath'?: string;
    /**
     * Whether this person if from art department
     * @type {boolean}
     * @memberof StaffBase
     */
    'artDepartment'?: boolean;
    /**
     * Whether this person is an art director
     * @type {boolean}
     * @memberof StaffBase
     */
    'artDirector'?: boolean;
    /**
     * Whether this person is a production designer
     * @type {boolean}
     * @memberof StaffBase
     */
    'productionDesigner'?: boolean;
    /**
     * Whether this person is from camera and electrical department
     * @type {boolean}
     * @memberof StaffBase
     */
    'cameraAndElectricalDepartment'?: boolean;
    /**
     * Whether this person is a cinematographer
     * @type {boolean}
     * @memberof StaffBase
     */
    'cinematographer'?: boolean;
    /**
     * Whether this person is from casting department
     * @type {boolean}
     * @memberof StaffBase
     */
    'castingDepartment'?: boolean;
    /**
     * Whether this person is from costume department
     * @type {boolean}
     * @memberof StaffBase
     */
    'costumeDepartment'?: boolean;
    /**
     * Whether this person is a custume designer
     * @type {boolean}
     * @memberof StaffBase
     */
    'costumeDesigner'?: boolean;
    /**
     * Whether this person is a director
     * @type {boolean}
     * @memberof StaffBase
     */
    'director'?: boolean;
    /**
     * Whether this person is an assistant or secound unit director director
     * @type {boolean}
     * @memberof StaffBase
     */
    'assistantOrSecondUnitDirector'?: boolean;
    /**
     * Whether this person is an exhibit and tttraction staff
     * @type {boolean}
     * @memberof StaffBase
     */
    'exhibitAndAttractionStaff'?: boolean;
    /**
     * Whether this person is a film editor
     * @type {boolean}
     * @memberof StaffBase
     */
    'filmEditor'?: boolean;
    /**
     * Whether this person is a linguist
     * @type {boolean}
     * @memberof StaffBase
     */
    'linguist'?: boolean;
    /**
     * Whether this person is a location staff
     * @type {boolean}
     * @memberof StaffBase
     */
    'locationStaff'?: boolean;
    /**
     * Whether this person is a make-up staff
     * @type {boolean}
     * @memberof StaffBase
     */
    'makeupStaff'?: boolean;
    /**
     * Whether this person is from music department
     * @type {boolean}
     * @memberof StaffBase
     */
    'musicDepartment'?: boolean;
    /**
     * Whether this person is a composer
     * @type {boolean}
     * @memberof StaffBase
     */
    'composer'?: boolean;
    /**
     * Whether this person is a personal assistant
     * @type {boolean}
     * @memberof StaffBase
     */
    'personalAssistant'?: boolean;
    /**
     * Whether this person is a producer
     * @type {boolean}
     * @memberof StaffBase
     */
    'producer'?: boolean;
    /**
     * Whether this person is a production associate
     * @type {boolean}
     * @memberof StaffBase
     */
    'productionAssociate'?: boolean;
    /**
     * Whether this person is a production staff
     * @type {boolean}
     * @memberof StaffBase
     */
    'productionStaff'?: boolean;
    /**
     * Whether this person is a publication staff
     * @type {boolean}
     * @memberof StaffBase
     */
    'publicationStaff'?: boolean;
    /**
     * Whether this person is a science consultant
     * @type {boolean}
     * @memberof StaffBase
     */
    'scienceConsultant'?: boolean;
    /**
     * Whether this person is from sound department
     * @type {boolean}
     * @memberof StaffBase
     */
    'soundDepartment'?: boolean;
    /**
     * Whether this person is a special and visual effects staff
     * @type {boolean}
     * @memberof StaffBase
     */
    'specialAndVisualEffectsStaff'?: boolean;
    /**
     * Whether this person is an author
     * @type {boolean}
     * @memberof StaffBase
     */
    'author'?: boolean;
    /**
     * Whether this person is an audio author
     * @type {boolean}
     * @memberof StaffBase
     */
    'audioAuthor'?: boolean;
    /**
     * Whether this person is a calendar artist
     * @type {boolean}
     * @memberof StaffBase
     */
    'calendarArtist'?: boolean;
    /**
     * Whether this person is a comic artist
     * @type {boolean}
     * @memberof StaffBase
     */
    'comicArtist'?: boolean;
    /**
     * Whether this person is a comic author
     * @type {boolean}
     * @memberof StaffBase
     */
    'comicAuthor'?: boolean;
    /**
     * Whether this person is a comic color artist
     * @type {boolean}
     * @memberof StaffBase
     */
    'comicColorArtist'?: boolean;
    /**
     * Whether this person is a comic interior artist
     * @type {boolean}
     * @memberof StaffBase
     */
    'comicInteriorArtist'?: boolean;
    /**
     * Whether this person is a comic ink artist
     * @type {boolean}
     * @memberof StaffBase
     */
    'comicInkArtist'?: boolean;
    /**
     * Whether this person is a comic pencil artist
     * @type {boolean}
     * @memberof StaffBase
     */
    'comicPencilArtist'?: boolean;
    /**
     * Whether this person is a comic letter artist
     * @type {boolean}
     * @memberof StaffBase
     */
    'comicLetterArtist'?: boolean;
    /**
     * Whether this person is a comic strip artist
     * @type {boolean}
     * @memberof StaffBase
     */
    'comicStripArtist'?: boolean;
    /**
     * Whether this person is a game artist
     * @type {boolean}
     * @memberof StaffBase
     */
    'gameArtist'?: boolean;
    /**
     * Whether this person is a game author
     * @type {boolean}
     * @memberof StaffBase
     */
    'gameAuthor'?: boolean;
    /**
     * Whether this person is a novel artist
     * @type {boolean}
     * @memberof StaffBase
     */
    'novelArtist'?: boolean;
    /**
     * Whether this person is a novel author
     * @type {boolean}
     * @memberof StaffBase
     */
    'novelAuthor'?: boolean;
    /**
     * Whether this person is a reference artist
     * @type {boolean}
     * @memberof StaffBase
     */
    'referenceArtist'?: boolean;
    /**
     * Whether this person is a reference author
     * @type {boolean}
     * @memberof StaffBase
     */
    'referenceAuthor'?: boolean;
    /**
     * Whether this person is a publication artist
     * @type {boolean}
     * @memberof StaffBase
     */
    'publicationArtist'?: boolean;
    /**
     * Whether this person is a publication designer
     * @type {boolean}
     * @memberof StaffBase
     */
    'publicationDesigner'?: boolean;
    /**
     * Whether this person is a publication editor
     * @type {boolean}
     * @memberof StaffBase
     */
    'publicationEditor'?: boolean;
    /**
     * Whether this person is a publication artist
     * @type {boolean}
     * @memberof StaffBase
     */
    'publicityArtist'?: boolean;
    /**
     * Whether this person is a part of CBS digital staff
     * @type {boolean}
     * @memberof StaffBase
     */
    'cbsDigitalStaff'?: boolean;
    /**
     * Whether this person is a part of ILM production staff
     * @type {boolean}
     * @memberof StaffBase
     */
    'ilmProductionStaff'?: boolean;
    /**
     * Whether this person is a special features artist
     * @type {boolean}
     * @memberof StaffBase
     */
    'specialFeaturesStaff'?: boolean;
    /**
     * Whether this person is a story editor
     * @type {boolean}
     * @memberof StaffBase
     */
    'storyEditor'?: boolean;
    /**
     * Whether this person is a studio executive
     * @type {boolean}
     * @memberof StaffBase
     */
    'studioExecutive'?: boolean;
    /**
     * Whether this person is from stunt department
     * @type {boolean}
     * @memberof StaffBase
     */
    'stuntDepartment'?: boolean;
    /**
     * Whether this person is from transportation department
     * @type {boolean}
     * @memberof StaffBase
     */
    'transportationDepartment'?: boolean;
    /**
     * Whether this person is video game production staff
     * @type {boolean}
     * @memberof StaffBase
     */
    'videoGameProductionStaff'?: boolean;
    /**
     * Whether this person is a writer
     * @type {boolean}
     * @memberof StaffBase
     */
    'writer'?: boolean;
}

/**
 * AnimalApi - axios parameter creator
 * @export
 */
export const AnimalApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrival of a single animal
         * @param {string} uid Animal unique ID
         * @param {string} [apiKey] API key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        animalGet: async (uid: string, apiKey?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('animalGet', 'uid', uid)
            const localVarPath = `/animal`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (uid !== undefined) {
                localVarQueryParameter['uid'] = uid;
            }

            if (apiKey !== undefined) {
                localVarQueryParameter['apiKey'] = apiKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Pagination over animals
         * @param {number} [pageNumber] Zero-based page number
         * @param {number} [pageSize] Page size
         * @param {string} [apiKey] API key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        animalSearchGet: async (pageNumber?: number, pageSize?: number, apiKey?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/animal/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (apiKey !== undefined) {
                localVarQueryParameter['apiKey'] = apiKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Searching animals
         * @param {number} [pageNumber] Zero-based page number
         * @param {number} [pageSize] Page size
         * @param {string} [sort] Sorting, serialized like this: fieldName,ASC;anotherFieldName,DESC
         * @param {string} [apiKey] API key
         * @param {string} [name] Animal name
         * @param {boolean} [earthAnimal] Whether it should be an earth animal
         * @param {boolean} [earthInsect] Whether it should be an earth insect
         * @param {boolean} [avian] Whether it should be an avian
         * @param {boolean} [canine] Whether it should be a canine
         * @param {boolean} [feline] Whether it should be a feline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        animalSearchPost: async (pageNumber?: number, pageSize?: number, sort?: string, apiKey?: string, name?: string, earthAnimal?: boolean, earthInsect?: boolean, avian?: boolean, canine?: boolean, feline?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/animal/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (apiKey !== undefined) {
                localVarQueryParameter['apiKey'] = apiKey;
            }


            if (name !== undefined) { 
                localVarFormParams.set('name', name as any);
            }
    
            if (earthAnimal !== undefined) { 
                localVarFormParams.set('earthAnimal', earthAnimal as any);
            }
    
            if (earthInsect !== undefined) { 
                localVarFormParams.set('earthInsect', earthInsect as any);
            }
    
            if (avian !== undefined) { 
                localVarFormParams.set('avian', avian as any);
            }
    
            if (canine !== undefined) { 
                localVarFormParams.set('canine', canine as any);
            }
    
            if (feline !== undefined) { 
                localVarFormParams.set('feline', feline as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AnimalApi - functional programming interface
 * @export
 */
export const AnimalApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AnimalApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrival of a single animal
         * @param {string} uid Animal unique ID
         * @param {string} [apiKey] API key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async animalGet(uid: string, apiKey?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnimalFullResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.animalGet(uid, apiKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Pagination over animals
         * @param {number} [pageNumber] Zero-based page number
         * @param {number} [pageSize] Page size
         * @param {string} [apiKey] API key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async animalSearchGet(pageNumber?: number, pageSize?: number, apiKey?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnimalBaseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.animalSearchGet(pageNumber, pageSize, apiKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Searching animals
         * @param {number} [pageNumber] Zero-based page number
         * @param {number} [pageSize] Page size
         * @param {string} [sort] Sorting, serialized like this: fieldName,ASC;anotherFieldName,DESC
         * @param {string} [apiKey] API key
         * @param {string} [name] Animal name
         * @param {boolean} [earthAnimal] Whether it should be an earth animal
         * @param {boolean} [earthInsect] Whether it should be an earth insect
         * @param {boolean} [avian] Whether it should be an avian
         * @param {boolean} [canine] Whether it should be a canine
         * @param {boolean} [feline] Whether it should be a feline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async animalSearchPost(pageNumber?: number, pageSize?: number, sort?: string, apiKey?: string, name?: string, earthAnimal?: boolean, earthInsect?: boolean, avian?: boolean, canine?: boolean, feline?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnimalBaseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.animalSearchPost(pageNumber, pageSize, sort, apiKey, name, earthAnimal, earthInsect, avian, canine, feline, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AnimalApi - factory interface
 * @export
 */
export const AnimalApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AnimalApiFp(configuration)
    return {
        /**
         * Retrival of a single animal
         * @param {string} uid Animal unique ID
         * @param {string} [apiKey] API key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        animalGet(uid: string, apiKey?: string, options?: any): AxiosPromise<AnimalFullResponse> {
            return localVarFp.animalGet(uid, apiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Pagination over animals
         * @param {number} [pageNumber] Zero-based page number
         * @param {number} [pageSize] Page size
         * @param {string} [apiKey] API key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        animalSearchGet(pageNumber?: number, pageSize?: number, apiKey?: string, options?: any): AxiosPromise<AnimalBaseResponse> {
            return localVarFp.animalSearchGet(pageNumber, pageSize, apiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Searching animals
         * @param {number} [pageNumber] Zero-based page number
         * @param {number} [pageSize] Page size
         * @param {string} [sort] Sorting, serialized like this: fieldName,ASC;anotherFieldName,DESC
         * @param {string} [apiKey] API key
         * @param {string} [name] Animal name
         * @param {boolean} [earthAnimal] Whether it should be an earth animal
         * @param {boolean} [earthInsect] Whether it should be an earth insect
         * @param {boolean} [avian] Whether it should be an avian
         * @param {boolean} [canine] Whether it should be a canine
         * @param {boolean} [feline] Whether it should be a feline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        animalSearchPost(pageNumber?: number, pageSize?: number, sort?: string, apiKey?: string, name?: string, earthAnimal?: boolean, earthInsect?: boolean, avian?: boolean, canine?: boolean, feline?: boolean, options?: any): AxiosPromise<AnimalBaseResponse> {
            return localVarFp.animalSearchPost(pageNumber, pageSize, sort, apiKey, name, earthAnimal, earthInsect, avian, canine, feline, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AnimalApi - object-oriented interface
 * @export
 * @class AnimalApi
 * @extends {BaseAPI}
 */
export class AnimalApi extends BaseAPI {
    /**
     * Retrival of a single animal
     * @param {string} uid Animal unique ID
     * @param {string} [apiKey] API key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnimalApi
     */
    public animalGet(uid: string, apiKey?: string, options?: AxiosRequestConfig) {
        return AnimalApiFp(this.configuration).animalGet(uid, apiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Pagination over animals
     * @param {number} [pageNumber] Zero-based page number
     * @param {number} [pageSize] Page size
     * @param {string} [apiKey] API key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnimalApi
     */
    public animalSearchGet(pageNumber?: number, pageSize?: number, apiKey?: string, options?: AxiosRequestConfig) {
        return AnimalApiFp(this.configuration).animalSearchGet(pageNumber, pageSize, apiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Searching animals
     * @param {number} [pageNumber] Zero-based page number
     * @param {number} [pageSize] Page size
     * @param {string} [sort] Sorting, serialized like this: fieldName,ASC;anotherFieldName,DESC
     * @param {string} [apiKey] API key
     * @param {string} [name] Animal name
     * @param {boolean} [earthAnimal] Whether it should be an earth animal
     * @param {boolean} [earthInsect] Whether it should be an earth insect
     * @param {boolean} [avian] Whether it should be an avian
     * @param {boolean} [canine] Whether it should be a canine
     * @param {boolean} [feline] Whether it should be a feline
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnimalApi
     */
    public animalSearchPost(pageNumber?: number, pageSize?: number, sort?: string, apiKey?: string, name?: string, earthAnimal?: boolean, earthInsect?: boolean, avian?: boolean, canine?: boolean, feline?: boolean, options?: AxiosRequestConfig) {
        return AnimalApiFp(this.configuration).animalSearchPost(pageNumber, pageSize, sort, apiKey, name, earthAnimal, earthInsect, avian, canine, feline, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AstronomicalObjectApi - axios parameter creator
 * @export
 */
export const AstronomicalObjectApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrival of a single astronomical object
         * @param {string} uid Astronomical object\&#39;s unique ID
         * @param {string} [apiKey] API key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        astronomicalObjectGet: async (uid: string, apiKey?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('astronomicalObjectGet', 'uid', uid)
            const localVarPath = `/astronomicalObject`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (uid !== undefined) {
                localVarQueryParameter['uid'] = uid;
            }

            if (apiKey !== undefined) {
                localVarQueryParameter['apiKey'] = apiKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Pagination over astronomical objects
         * @param {number} [pageNumber] Zero-based page number
         * @param {number} [pageSize] Page size
         * @param {string} [apiKey] API key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        astronomicalObjectSearchGet: async (pageNumber?: number, pageSize?: number, apiKey?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/astronomicalObject/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (apiKey !== undefined) {
                localVarQueryParameter['apiKey'] = apiKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Searching astronomical objects
         * @param {number} [pageNumber] Zero-based page number
         * @param {number} [pageSize] Page size
         * @param {string} [sort] Sorting, serialized like this: fieldName,ASC;anotherFieldName,DESC
         * @param {string} [apiKey] API key
         * @param {string} [name] Astronomical object name
         * @param {string} [astronomicalObjectType] Type of astronomical object
         * @param {string} [locationUid] Unique ID of astronomical object containing objects being searched
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        astronomicalObjectSearchPost: async (pageNumber?: number, pageSize?: number, sort?: string, apiKey?: string, name?: string, astronomicalObjectType?: string, locationUid?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/astronomicalObject/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (apiKey !== undefined) {
                localVarQueryParameter['apiKey'] = apiKey;
            }


            if (name !== undefined) { 
                localVarFormParams.set('name', name as any);
            }
    
            if (astronomicalObjectType !== undefined) { 
                localVarFormParams.set('astronomicalObjectType', astronomicalObjectType as any);
            }
    
            if (locationUid !== undefined) { 
                localVarFormParams.set('locationUid', locationUid as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AstronomicalObjectApi - functional programming interface
 * @export
 */
export const AstronomicalObjectApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AstronomicalObjectApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrival of a single astronomical object
         * @param {string} uid Astronomical object\&#39;s unique ID
         * @param {string} [apiKey] API key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async astronomicalObjectGet(uid: string, apiKey?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AstronomicalObjectFullResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.astronomicalObjectGet(uid, apiKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Pagination over astronomical objects
         * @param {number} [pageNumber] Zero-based page number
         * @param {number} [pageSize] Page size
         * @param {string} [apiKey] API key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async astronomicalObjectSearchGet(pageNumber?: number, pageSize?: number, apiKey?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AstronomicalObjectBaseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.astronomicalObjectSearchGet(pageNumber, pageSize, apiKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Searching astronomical objects
         * @param {number} [pageNumber] Zero-based page number
         * @param {number} [pageSize] Page size
         * @param {string} [sort] Sorting, serialized like this: fieldName,ASC;anotherFieldName,DESC
         * @param {string} [apiKey] API key
         * @param {string} [name] Astronomical object name
         * @param {string} [astronomicalObjectType] Type of astronomical object
         * @param {string} [locationUid] Unique ID of astronomical object containing objects being searched
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async astronomicalObjectSearchPost(pageNumber?: number, pageSize?: number, sort?: string, apiKey?: string, name?: string, astronomicalObjectType?: string, locationUid?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AstronomicalObjectBaseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.astronomicalObjectSearchPost(pageNumber, pageSize, sort, apiKey, name, astronomicalObjectType, locationUid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AstronomicalObjectApi - factory interface
 * @export
 */
export const AstronomicalObjectApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AstronomicalObjectApiFp(configuration)
    return {
        /**
         * Retrival of a single astronomical object
         * @param {string} uid Astronomical object\&#39;s unique ID
         * @param {string} [apiKey] API key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        astronomicalObjectGet(uid: string, apiKey?: string, options?: any): AxiosPromise<AstronomicalObjectFullResponse> {
            return localVarFp.astronomicalObjectGet(uid, apiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Pagination over astronomical objects
         * @param {number} [pageNumber] Zero-based page number
         * @param {number} [pageSize] Page size
         * @param {string} [apiKey] API key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        astronomicalObjectSearchGet(pageNumber?: number, pageSize?: number, apiKey?: string, options?: any): AxiosPromise<AstronomicalObjectBaseResponse> {
            return localVarFp.astronomicalObjectSearchGet(pageNumber, pageSize, apiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Searching astronomical objects
         * @param {number} [pageNumber] Zero-based page number
         * @param {number} [pageSize] Page size
         * @param {string} [sort] Sorting, serialized like this: fieldName,ASC;anotherFieldName,DESC
         * @param {string} [apiKey] API key
         * @param {string} [name] Astronomical object name
         * @param {string} [astronomicalObjectType] Type of astronomical object
         * @param {string} [locationUid] Unique ID of astronomical object containing objects being searched
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        astronomicalObjectSearchPost(pageNumber?: number, pageSize?: number, sort?: string, apiKey?: string, name?: string, astronomicalObjectType?: string, locationUid?: string, options?: any): AxiosPromise<AstronomicalObjectBaseResponse> {
            return localVarFp.astronomicalObjectSearchPost(pageNumber, pageSize, sort, apiKey, name, astronomicalObjectType, locationUid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AstronomicalObjectApi - object-oriented interface
 * @export
 * @class AstronomicalObjectApi
 * @extends {BaseAPI}
 */
export class AstronomicalObjectApi extends BaseAPI {
    /**
     * Retrival of a single astronomical object
     * @param {string} uid Astronomical object\&#39;s unique ID
     * @param {string} [apiKey] API key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AstronomicalObjectApi
     */
    public astronomicalObjectGet(uid: string, apiKey?: string, options?: AxiosRequestConfig) {
        return AstronomicalObjectApiFp(this.configuration).astronomicalObjectGet(uid, apiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Pagination over astronomical objects
     * @param {number} [pageNumber] Zero-based page number
     * @param {number} [pageSize] Page size
     * @param {string} [apiKey] API key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AstronomicalObjectApi
     */
    public astronomicalObjectSearchGet(pageNumber?: number, pageSize?: number, apiKey?: string, options?: AxiosRequestConfig) {
        return AstronomicalObjectApiFp(this.configuration).astronomicalObjectSearchGet(pageNumber, pageSize, apiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Searching astronomical objects
     * @param {number} [pageNumber] Zero-based page number
     * @param {number} [pageSize] Page size
     * @param {string} [sort] Sorting, serialized like this: fieldName,ASC;anotherFieldName,DESC
     * @param {string} [apiKey] API key
     * @param {string} [name] Astronomical object name
     * @param {string} [astronomicalObjectType] Type of astronomical object
     * @param {string} [locationUid] Unique ID of astronomical object containing objects being searched
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AstronomicalObjectApi
     */
    public astronomicalObjectSearchPost(pageNumber?: number, pageSize?: number, sort?: string, apiKey?: string, name?: string, astronomicalObjectType?: string, locationUid?: string, options?: AxiosRequestConfig) {
        return AstronomicalObjectApiFp(this.configuration).astronomicalObjectSearchPost(pageNumber, pageSize, sort, apiKey, name, astronomicalObjectType, locationUid, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BookApi - axios parameter creator
 * @export
 */
export const BookApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrival of a single book
         * @param {string} uid Book unique ID
         * @param {string} [apiKey] API key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookGet: async (uid: string, apiKey?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('bookGet', 'uid', uid)
            const localVarPath = `/book`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (uid !== undefined) {
                localVarQueryParameter['uid'] = uid;
            }

            if (apiKey !== undefined) {
                localVarQueryParameter['apiKey'] = apiKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Pagination over books
         * @param {number} [pageNumber] Zero-based page number
         * @param {number} [pageSize] Page size
         * @param {string} [apiKey] API key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookSearchGet: async (pageNumber?: number, pageSize?: number, apiKey?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/book/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (apiKey !== undefined) {
                localVarQueryParameter['apiKey'] = apiKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Searching books
         * @param {number} [pageNumber] Zero-based page number
         * @param {number} [pageSize] Page size
         * @param {string} [sort] Sorting, serialized like this: fieldName,ASC;anotherFieldName,DESC
         * @param {string} [apiKey] API key
         * @param {string} [title] Book title
         * @param {number} [publishedYearFrom] Starting year the book was published
         * @param {number} [publishedYearTo] Ending year the book was published
         * @param {number} [numberOfPagesFrom] Minimal number of pages
         * @param {number} [numberOfPagesTo] Maximal number of pages
         * @param {number} [stardateFrom] Starting stardate of book story
         * @param {number} [stardateTo] Ending stardate of book story
         * @param {number} [yearFrom] Starting year of book story
         * @param {number} [yearTo] Ending year of book story
         * @param {boolean} [novel] Whether it should be a novel
         * @param {boolean} [referenceBook] Whether it should be a reference book
         * @param {boolean} [biographyBook] Whether it should be a biography book
         * @param {boolean} [rolePlayingBook] Whether it should be a role playing book
         * @param {boolean} [eBook] Whether it should be an e-book
         * @param {boolean} [anthology] Whether it should be an anthology
         * @param {boolean} [novelization] Whether it should be novelization
         * @param {boolean} [audiobook] Whether it should be an audiobook
         * @param {boolean} [audiobookAbridged] Whether it should be an audiobook, abridged
         * @param {number} [audiobookPublishedYearFrom] Starting year the audiobook was published
         * @param {number} [audiobookPublishedYearTo] Ending year the audiobook was published
         * @param {number} [audiobookRunTimeFrom] Minimal audiobook run time, in minutes
         * @param {number} [audiobookRunTimeTo] Maximal audiobook run time, in minutes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookSearchPost: async (pageNumber?: number, pageSize?: number, sort?: string, apiKey?: string, title?: string, publishedYearFrom?: number, publishedYearTo?: number, numberOfPagesFrom?: number, numberOfPagesTo?: number, stardateFrom?: number, stardateTo?: number, yearFrom?: number, yearTo?: number, novel?: boolean, referenceBook?: boolean, biographyBook?: boolean, rolePlayingBook?: boolean, eBook?: boolean, anthology?: boolean, novelization?: boolean, audiobook?: boolean, audiobookAbridged?: boolean, audiobookPublishedYearFrom?: number, audiobookPublishedYearTo?: number, audiobookRunTimeFrom?: number, audiobookRunTimeTo?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/book/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (apiKey !== undefined) {
                localVarQueryParameter['apiKey'] = apiKey;
            }


            if (title !== undefined) { 
                localVarFormParams.set('title', title as any);
            }
    
            if (publishedYearFrom !== undefined) { 
                localVarFormParams.set('publishedYearFrom', publishedYearFrom as any);
            }
    
            if (publishedYearTo !== undefined) { 
                localVarFormParams.set('publishedYearTo', publishedYearTo as any);
            }
    
            if (numberOfPagesFrom !== undefined) { 
                localVarFormParams.set('numberOfPagesFrom', numberOfPagesFrom as any);
            }
    
            if (numberOfPagesTo !== undefined) { 
                localVarFormParams.set('numberOfPagesTo', numberOfPagesTo as any);
            }
    
            if (stardateFrom !== undefined) { 
                localVarFormParams.set('stardateFrom', stardateFrom as any);
            }
    
            if (stardateTo !== undefined) { 
                localVarFormParams.set('stardateTo', stardateTo as any);
            }
    
            if (yearFrom !== undefined) { 
                localVarFormParams.set('yearFrom', yearFrom as any);
            }
    
            if (yearTo !== undefined) { 
                localVarFormParams.set('yearTo', yearTo as any);
            }
    
            if (novel !== undefined) { 
                localVarFormParams.set('novel', novel as any);
            }
    
            if (referenceBook !== undefined) { 
                localVarFormParams.set('referenceBook', referenceBook as any);
            }
    
            if (biographyBook !== undefined) { 
                localVarFormParams.set('biographyBook', biographyBook as any);
            }
    
            if (rolePlayingBook !== undefined) { 
                localVarFormParams.set('rolePlayingBook', rolePlayingBook as any);
            }
    
            if (eBook !== undefined) { 
                localVarFormParams.set('eBook', eBook as any);
            }
    
            if (anthology !== undefined) { 
                localVarFormParams.set('anthology', anthology as any);
            }
    
            if (novelization !== undefined) { 
                localVarFormParams.set('novelization', novelization as any);
            }
    
            if (audiobook !== undefined) { 
                localVarFormParams.set('audiobook', audiobook as any);
            }
    
            if (audiobookAbridged !== undefined) { 
                localVarFormParams.set('audiobookAbridged', audiobookAbridged as any);
            }
    
            if (audiobookPublishedYearFrom !== undefined) { 
                localVarFormParams.set('audiobookPublishedYearFrom', audiobookPublishedYearFrom as any);
            }
    
            if (audiobookPublishedYearTo !== undefined) { 
                localVarFormParams.set('audiobookPublishedYearTo', audiobookPublishedYearTo as any);
            }
    
            if (audiobookRunTimeFrom !== undefined) { 
                localVarFormParams.set('audiobookRunTimeFrom', audiobookRunTimeFrom as any);
            }
    
            if (audiobookRunTimeTo !== undefined) { 
                localVarFormParams.set('audiobookRunTimeTo', audiobookRunTimeTo as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BookApi - functional programming interface
 * @export
 */
export const BookApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BookApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrival of a single book
         * @param {string} uid Book unique ID
         * @param {string} [apiKey] API key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bookGet(uid: string, apiKey?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BookFullResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bookGet(uid, apiKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Pagination over books
         * @param {number} [pageNumber] Zero-based page number
         * @param {number} [pageSize] Page size
         * @param {string} [apiKey] API key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bookSearchGet(pageNumber?: number, pageSize?: number, apiKey?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BookBaseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bookSearchGet(pageNumber, pageSize, apiKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Searching books
         * @param {number} [pageNumber] Zero-based page number
         * @param {number} [pageSize] Page size
         * @param {string} [sort] Sorting, serialized like this: fieldName,ASC;anotherFieldName,DESC
         * @param {string} [apiKey] API key
         * @param {string} [title] Book title
         * @param {number} [publishedYearFrom] Starting year the book was published
         * @param {number} [publishedYearTo] Ending year the book was published
         * @param {number} [numberOfPagesFrom] Minimal number of pages
         * @param {number} [numberOfPagesTo] Maximal number of pages
         * @param {number} [stardateFrom] Starting stardate of book story
         * @param {number} [stardateTo] Ending stardate of book story
         * @param {number} [yearFrom] Starting year of book story
         * @param {number} [yearTo] Ending year of book story
         * @param {boolean} [novel] Whether it should be a novel
         * @param {boolean} [referenceBook] Whether it should be a reference book
         * @param {boolean} [biographyBook] Whether it should be a biography book
         * @param {boolean} [rolePlayingBook] Whether it should be a role playing book
         * @param {boolean} [eBook] Whether it should be an e-book
         * @param {boolean} [anthology] Whether it should be an anthology
         * @param {boolean} [novelization] Whether it should be novelization
         * @param {boolean} [audiobook] Whether it should be an audiobook
         * @param {boolean} [audiobookAbridged] Whether it should be an audiobook, abridged
         * @param {number} [audiobookPublishedYearFrom] Starting year the audiobook was published
         * @param {number} [audiobookPublishedYearTo] Ending year the audiobook was published
         * @param {number} [audiobookRunTimeFrom] Minimal audiobook run time, in minutes
         * @param {number} [audiobookRunTimeTo] Maximal audiobook run time, in minutes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bookSearchPost(pageNumber?: number, pageSize?: number, sort?: string, apiKey?: string, title?: string, publishedYearFrom?: number, publishedYearTo?: number, numberOfPagesFrom?: number, numberOfPagesTo?: number, stardateFrom?: number, stardateTo?: number, yearFrom?: number, yearTo?: number, novel?: boolean, referenceBook?: boolean, biographyBook?: boolean, rolePlayingBook?: boolean, eBook?: boolean, anthology?: boolean, novelization?: boolean, audiobook?: boolean, audiobookAbridged?: boolean, audiobookPublishedYearFrom?: number, audiobookPublishedYearTo?: number, audiobookRunTimeFrom?: number, audiobookRunTimeTo?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BookBaseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bookSearchPost(pageNumber, pageSize, sort, apiKey, title, publishedYearFrom, publishedYearTo, numberOfPagesFrom, numberOfPagesTo, stardateFrom, stardateTo, yearFrom, yearTo, novel, referenceBook, biographyBook, rolePlayingBook, eBook, anthology, novelization, audiobook, audiobookAbridged, audiobookPublishedYearFrom, audiobookPublishedYearTo, audiobookRunTimeFrom, audiobookRunTimeTo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BookApi - factory interface
 * @export
 */
export const BookApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BookApiFp(configuration)
    return {
        /**
         * Retrival of a single book
         * @param {string} uid Book unique ID
         * @param {string} [apiKey] API key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookGet(uid: string, apiKey?: string, options?: any): AxiosPromise<BookFullResponse> {
            return localVarFp.bookGet(uid, apiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Pagination over books
         * @param {number} [pageNumber] Zero-based page number
         * @param {number} [pageSize] Page size
         * @param {string} [apiKey] API key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookSearchGet(pageNumber?: number, pageSize?: number, apiKey?: string, options?: any): AxiosPromise<BookBaseResponse> {
            return localVarFp.bookSearchGet(pageNumber, pageSize, apiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Searching books
         * @param {number} [pageNumber] Zero-based page number
         * @param {number} [pageSize] Page size
         * @param {string} [sort] Sorting, serialized like this: fieldName,ASC;anotherFieldName,DESC
         * @param {string} [apiKey] API key
         * @param {string} [title] Book title
         * @param {number} [publishedYearFrom] Starting year the book was published
         * @param {number} [publishedYearTo] Ending year the book was published
         * @param {number} [numberOfPagesFrom] Minimal number of pages
         * @param {number} [numberOfPagesTo] Maximal number of pages
         * @param {number} [stardateFrom] Starting stardate of book story
         * @param {number} [stardateTo] Ending stardate of book story
         * @param {number} [yearFrom] Starting year of book story
         * @param {number} [yearTo] Ending year of book story
         * @param {boolean} [novel] Whether it should be a novel
         * @param {boolean} [referenceBook] Whether it should be a reference book
         * @param {boolean} [biographyBook] Whether it should be a biography book
         * @param {boolean} [rolePlayingBook] Whether it should be a role playing book
         * @param {boolean} [eBook] Whether it should be an e-book
         * @param {boolean} [anthology] Whether it should be an anthology
         * @param {boolean} [novelization] Whether it should be novelization
         * @param {boolean} [audiobook] Whether it should be an audiobook
         * @param {boolean} [audiobookAbridged] Whether it should be an audiobook, abridged
         * @param {number} [audiobookPublishedYearFrom] Starting year the audiobook was published
         * @param {number} [audiobookPublishedYearTo] Ending year the audiobook was published
         * @param {number} [audiobookRunTimeFrom] Minimal audiobook run time, in minutes
         * @param {number} [audiobookRunTimeTo] Maximal audiobook run time, in minutes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookSearchPost(pageNumber?: number, pageSize?: number, sort?: string, apiKey?: string, title?: string, publishedYearFrom?: number, publishedYearTo?: number, numberOfPagesFrom?: number, numberOfPagesTo?: number, stardateFrom?: number, stardateTo?: number, yearFrom?: number, yearTo?: number, novel?: boolean, referenceBook?: boolean, biographyBook?: boolean, rolePlayingBook?: boolean, eBook?: boolean, anthology?: boolean, novelization?: boolean, audiobook?: boolean, audiobookAbridged?: boolean, audiobookPublishedYearFrom?: number, audiobookPublishedYearTo?: number, audiobookRunTimeFrom?: number, audiobookRunTimeTo?: number, options?: any): AxiosPromise<BookBaseResponse> {
            return localVarFp.bookSearchPost(pageNumber, pageSize, sort, apiKey, title, publishedYearFrom, publishedYearTo, numberOfPagesFrom, numberOfPagesTo, stardateFrom, stardateTo, yearFrom, yearTo, novel, referenceBook, biographyBook, rolePlayingBook, eBook, anthology, novelization, audiobook, audiobookAbridged, audiobookPublishedYearFrom, audiobookPublishedYearTo, audiobookRunTimeFrom, audiobookRunTimeTo, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BookApi - object-oriented interface
 * @export
 * @class BookApi
 * @extends {BaseAPI}
 */
export class BookApi extends BaseAPI {
    /**
     * Retrival of a single book
     * @param {string} uid Book unique ID
     * @param {string} [apiKey] API key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookApi
     */
    public bookGet(uid: string, apiKey?: string, options?: AxiosRequestConfig) {
        return BookApiFp(this.configuration).bookGet(uid, apiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Pagination over books
     * @param {number} [pageNumber] Zero-based page number
     * @param {number} [pageSize] Page size
     * @param {string} [apiKey] API key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookApi
     */
    public bookSearchGet(pageNumber?: number, pageSize?: number, apiKey?: string, options?: AxiosRequestConfig) {
        return BookApiFp(this.configuration).bookSearchGet(pageNumber, pageSize, apiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Searching books
     * @param {number} [pageNumber] Zero-based page number
     * @param {number} [pageSize] Page size
     * @param {string} [sort] Sorting, serialized like this: fieldName,ASC;anotherFieldName,DESC
     * @param {string} [apiKey] API key
     * @param {string} [title] Book title
     * @param {number} [publishedYearFrom] Starting year the book was published
     * @param {number} [publishedYearTo] Ending year the book was published
     * @param {number} [numberOfPagesFrom] Minimal number of pages
     * @param {number} [numberOfPagesTo] Maximal number of pages
     * @param {number} [stardateFrom] Starting stardate of book story
     * @param {number} [stardateTo] Ending stardate of book story
     * @param {number} [yearFrom] Starting year of book story
     * @param {number} [yearTo] Ending year of book story
     * @param {boolean} [novel] Whether it should be a novel
     * @param {boolean} [referenceBook] Whether it should be a reference book
     * @param {boolean} [biographyBook] Whether it should be a biography book
     * @param {boolean} [rolePlayingBook] Whether it should be a role playing book
     * @param {boolean} [eBook] Whether it should be an e-book
     * @param {boolean} [anthology] Whether it should be an anthology
     * @param {boolean} [novelization] Whether it should be novelization
     * @param {boolean} [audiobook] Whether it should be an audiobook
     * @param {boolean} [audiobookAbridged] Whether it should be an audiobook, abridged
     * @param {number} [audiobookPublishedYearFrom] Starting year the audiobook was published
     * @param {number} [audiobookPublishedYearTo] Ending year the audiobook was published
     * @param {number} [audiobookRunTimeFrom] Minimal audiobook run time, in minutes
     * @param {number} [audiobookRunTimeTo] Maximal audiobook run time, in minutes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookApi
     */
    public bookSearchPost(pageNumber?: number, pageSize?: number, sort?: string, apiKey?: string, title?: string, publishedYearFrom?: number, publishedYearTo?: number, numberOfPagesFrom?: number, numberOfPagesTo?: number, stardateFrom?: number, stardateTo?: number, yearFrom?: number, yearTo?: number, novel?: boolean, referenceBook?: boolean, biographyBook?: boolean, rolePlayingBook?: boolean, eBook?: boolean, anthology?: boolean, novelization?: boolean, audiobook?: boolean, audiobookAbridged?: boolean, audiobookPublishedYearFrom?: number, audiobookPublishedYearTo?: number, audiobookRunTimeFrom?: number, audiobookRunTimeTo?: number, options?: AxiosRequestConfig) {
        return BookApiFp(this.configuration).bookSearchPost(pageNumber, pageSize, sort, apiKey, title, publishedYearFrom, publishedYearTo, numberOfPagesFrom, numberOfPagesTo, stardateFrom, stardateTo, yearFrom, yearTo, novel, referenceBook, biographyBook, rolePlayingBook, eBook, anthology, novelization, audiobook, audiobookAbridged, audiobookPublishedYearFrom, audiobookPublishedYearTo, audiobookRunTimeFrom, audiobookRunTimeTo, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BookCollectionApi - axios parameter creator
 * @export
 */
export const BookCollectionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrival of a single book collection
         * @param {string} uid Book collection unique ID
         * @param {string} [apiKey] API key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookCollectionGet: async (uid: string, apiKey?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('bookCollectionGet', 'uid', uid)
            const localVarPath = `/bookCollection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (uid !== undefined) {
                localVarQueryParameter['uid'] = uid;
            }

            if (apiKey !== undefined) {
                localVarQueryParameter['apiKey'] = apiKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Pagination over book collections
         * @param {number} [pageNumber] Zero-based page number
         * @param {number} [pageSize] Page size
         * @param {string} [apiKey] API key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookCollectionSearchGet: async (pageNumber?: number, pageSize?: number, apiKey?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bookCollection/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (apiKey !== undefined) {
                localVarQueryParameter['apiKey'] = apiKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Searching book collections
         * @param {number} [pageNumber] Zero-based page number
         * @param {number} [pageSize] Page size
         * @param {string} [sort] Sorting, serialized like this: fieldName,ASC;anotherFieldName,DESC
         * @param {string} [apiKey] API key
         * @param {string} [title] Book collection title
         * @param {number} [publishedYearFrom] Starting year the book collection was published
         * @param {number} [publishedYearTo] Ending year the book collection was published
         * @param {number} [numberOfPagesFrom] Minimal number of pages
         * @param {number} [numberOfPagesTo] Maximal number of pages
         * @param {number} [stardateFrom] Starting stardate of book collection stories
         * @param {number} [stardateTo] Ending stardate of book collections stories
         * @param {number} [yearFrom] Starting year of book collection stories
         * @param {number} [yearTo] Ending year of book collections stories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookCollectionSearchPost: async (pageNumber?: number, pageSize?: number, sort?: string, apiKey?: string, title?: string, publishedYearFrom?: number, publishedYearTo?: number, numberOfPagesFrom?: number, numberOfPagesTo?: number, stardateFrom?: number, stardateTo?: number, yearFrom?: number, yearTo?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bookCollection/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (apiKey !== undefined) {
                localVarQueryParameter['apiKey'] = apiKey;
            }


            if (title !== undefined) { 
                localVarFormParams.set('title', title as any);
            }
    
            if (publishedYearFrom !== undefined) { 
                localVarFormParams.set('publishedYearFrom', publishedYearFrom as any);
            }
    
            if (publishedYearTo !== undefined) { 
                localVarFormParams.set('publishedYearTo', publishedYearTo as any);
            }
    
            if (numberOfPagesFrom !== undefined) { 
                localVarFormParams.set('numberOfPagesFrom', numberOfPagesFrom as any);
            }
    
            if (numberOfPagesTo !== undefined) { 
                localVarFormParams.set('numberOfPagesTo', numberOfPagesTo as any);
            }
    
            if (stardateFrom !== undefined) { 
                localVarFormParams.set('stardateFrom', stardateFrom as any);
            }
    
            if (stardateTo !== undefined) { 
                localVarFormParams.set('stardateTo', stardateTo as any);
            }
    
            if (yearFrom !== undefined) { 
                localVarFormParams.set('yearFrom', yearFrom as any);
            }
    
            if (yearTo !== undefined) { 
                localVarFormParams.set('yearTo', yearTo as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BookCollectionApi - functional programming interface
 * @export
 */
export const BookCollectionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BookCollectionApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrival of a single book collection
         * @param {string} uid Book collection unique ID
         * @param {string} [apiKey] API key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bookCollectionGet(uid: string, apiKey?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BookCollectionFullResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bookCollectionGet(uid, apiKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Pagination over book collections
         * @param {number} [pageNumber] Zero-based page number
         * @param {number} [pageSize] Page size
         * @param {string} [apiKey] API key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bookCollectionSearchGet(pageNumber?: number, pageSize?: number, apiKey?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BookCollectionBaseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bookCollectionSearchGet(pageNumber, pageSize, apiKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Searching book collections
         * @param {number} [pageNumber] Zero-based page number
         * @param {number} [pageSize] Page size
         * @param {string} [sort] Sorting, serialized like this: fieldName,ASC;anotherFieldName,DESC
         * @param {string} [apiKey] API key
         * @param {string} [title] Book collection title
         * @param {number} [publishedYearFrom] Starting year the book collection was published
         * @param {number} [publishedYearTo] Ending year the book collection was published
         * @param {number} [numberOfPagesFrom] Minimal number of pages
         * @param {number} [numberOfPagesTo] Maximal number of pages
         * @param {number} [stardateFrom] Starting stardate of book collection stories
         * @param {number} [stardateTo] Ending stardate of book collections stories
         * @param {number} [yearFrom] Starting year of book collection stories
         * @param {number} [yearTo] Ending year of book collections stories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bookCollectionSearchPost(pageNumber?: number, pageSize?: number, sort?: string, apiKey?: string, title?: string, publishedYearFrom?: number, publishedYearTo?: number, numberOfPagesFrom?: number, numberOfPagesTo?: number, stardateFrom?: number, stardateTo?: number, yearFrom?: number, yearTo?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BookCollectionBaseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bookCollectionSearchPost(pageNumber, pageSize, sort, apiKey, title, publishedYearFrom, publishedYearTo, numberOfPagesFrom, numberOfPagesTo, stardateFrom, stardateTo, yearFrom, yearTo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BookCollectionApi - factory interface
 * @export
 */
export const BookCollectionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BookCollectionApiFp(configuration)
    return {
        /**
         * Retrival of a single book collection
         * @param {string} uid Book collection unique ID
         * @param {string} [apiKey] API key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookCollectionGet(uid: string, apiKey?: string, options?: any): AxiosPromise<BookCollectionFullResponse> {
            return localVarFp.bookCollectionGet(uid, apiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Pagination over book collections
         * @param {number} [pageNumber] Zero-based page number
         * @param {number} [pageSize] Page size
         * @param {string} [apiKey] API key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookCollectionSearchGet(pageNumber?: number, pageSize?: number, apiKey?: string, options?: any): AxiosPromise<BookCollectionBaseResponse> {
            return localVarFp.bookCollectionSearchGet(pageNumber, pageSize, apiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Searching book collections
         * @param {number} [pageNumber] Zero-based page number
         * @param {number} [pageSize] Page size
         * @param {string} [sort] Sorting, serialized like this: fieldName,ASC;anotherFieldName,DESC
         * @param {string} [apiKey] API key
         * @param {string} [title] Book collection title
         * @param {number} [publishedYearFrom] Starting year the book collection was published
         * @param {number} [publishedYearTo] Ending year the book collection was published
         * @param {number} [numberOfPagesFrom] Minimal number of pages
         * @param {number} [numberOfPagesTo] Maximal number of pages
         * @param {number} [stardateFrom] Starting stardate of book collection stories
         * @param {number} [stardateTo] Ending stardate of book collections stories
         * @param {number} [yearFrom] Starting year of book collection stories
         * @param {number} [yearTo] Ending year of book collections stories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookCollectionSearchPost(pageNumber?: number, pageSize?: number, sort?: string, apiKey?: string, title?: string, publishedYearFrom?: number, publishedYearTo?: number, numberOfPagesFrom?: number, numberOfPagesTo?: number, stardateFrom?: number, stardateTo?: number, yearFrom?: number, yearTo?: number, options?: any): AxiosPromise<BookCollectionBaseResponse> {
            return localVarFp.bookCollectionSearchPost(pageNumber, pageSize, sort, apiKey, title, publishedYearFrom, publishedYearTo, numberOfPagesFrom, numberOfPagesTo, stardateFrom, stardateTo, yearFrom, yearTo, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BookCollectionApi - object-oriented interface
 * @export
 * @class BookCollectionApi
 * @extends {BaseAPI}
 */
export class BookCollectionApi extends BaseAPI {
    /**
     * Retrival of a single book collection
     * @param {string} uid Book collection unique ID
     * @param {string} [apiKey] API key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookCollectionApi
     */
    public bookCollectionGet(uid: string, apiKey?: string, options?: AxiosRequestConfig) {
        return BookCollectionApiFp(this.configuration).bookCollectionGet(uid, apiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Pagination over book collections
     * @param {number} [pageNumber] Zero-based page number
     * @param {number} [pageSize] Page size
     * @param {string} [apiKey] API key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookCollectionApi
     */
    public bookCollectionSearchGet(pageNumber?: number, pageSize?: number, apiKey?: string, options?: AxiosRequestConfig) {
        return BookCollectionApiFp(this.configuration).bookCollectionSearchGet(pageNumber, pageSize, apiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Searching book collections
     * @param {number} [pageNumber] Zero-based page number
     * @param {number} [pageSize] Page size
     * @param {string} [sort] Sorting, serialized like this: fieldName,ASC;anotherFieldName,DESC
     * @param {string} [apiKey] API key
     * @param {string} [title] Book collection title
     * @param {number} [publishedYearFrom] Starting year the book collection was published
     * @param {number} [publishedYearTo] Ending year the book collection was published
     * @param {number} [numberOfPagesFrom] Minimal number of pages
     * @param {number} [numberOfPagesTo] Maximal number of pages
     * @param {number} [stardateFrom] Starting stardate of book collection stories
     * @param {number} [stardateTo] Ending stardate of book collections stories
     * @param {number} [yearFrom] Starting year of book collection stories
     * @param {number} [yearTo] Ending year of book collections stories
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookCollectionApi
     */
    public bookCollectionSearchPost(pageNumber?: number, pageSize?: number, sort?: string, apiKey?: string, title?: string, publishedYearFrom?: number, publishedYearTo?: number, numberOfPagesFrom?: number, numberOfPagesTo?: number, stardateFrom?: number, stardateTo?: number, yearFrom?: number, yearTo?: number, options?: AxiosRequestConfig) {
        return BookCollectionApiFp(this.configuration).bookCollectionSearchPost(pageNumber, pageSize, sort, apiKey, title, publishedYearFrom, publishedYearTo, numberOfPagesFrom, numberOfPagesTo, stardateFrom, stardateTo, yearFrom, yearTo, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BookSeriesApi - axios parameter creator
 * @export
 */
export const BookSeriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrival of a single book series
         * @param {string} uid Book series unique ID
         * @param {string} [apiKey] API key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookSeriesGet: async (uid: string, apiKey?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('bookSeriesGet', 'uid', uid)
            const localVarPath = `/bookSeries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (uid !== undefined) {
                localVarQueryParameter['uid'] = uid;
            }

            if (apiKey !== undefined) {
                localVarQueryParameter['apiKey'] = apiKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Pagination over book series
         * @param {number} [pageNumber] Zero-based page number
         * @param {number} [pageSize] Page size
         * @param {string} [apiKey] API key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookSeriesSearchGet: async (pageNumber?: number, pageSize?: number, apiKey?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bookSeries/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (apiKey !== undefined) {
                localVarQueryParameter['apiKey'] = apiKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Searching book series
         * @param {number} [pageNumber] Zero-based page number
         * @param {number} [pageSize] Page size
         * @param {string} [sort] Sorting, serialized like this: fieldName,ASC;anotherFieldName,DESC
         * @param {string} [apiKey] API key
         * @param {string} [title] Book series title
         * @param {number} [publishedYearFrom] Starting year the book series was published
         * @param {number} [publishedYearTo] Ending year the book series was published
         * @param {number} [numberOfBooksFrom] Minimal number of books
         * @param {number} [numberOfBooksTo] Maximal number of books
         * @param {number} [yearFrom] Starting year of book series stories
         * @param {number} [yearTo] Ending year of book series stories
         * @param {boolean} [miniseries] Whether it should be a miniseries
         * @param {boolean} [eBookSeries] Whether it should be an e-book series
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookSeriesSearchPost: async (pageNumber?: number, pageSize?: number, sort?: string, apiKey?: string, title?: string, publishedYearFrom?: number, publishedYearTo?: number, numberOfBooksFrom?: number, numberOfBooksTo?: number, yearFrom?: number, yearTo?: number, miniseries?: boolean, eBookSeries?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bookSeries/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (apiKey !== undefined) {
                localVarQueryParameter['apiKey'] = apiKey;
            }


            if (title !== undefined) { 
                localVarFormParams.set('title', title as any);
            }
    
            if (publishedYearFrom !== undefined) { 
                localVarFormParams.set('publishedYearFrom', publishedYearFrom as any);
            }
    
            if (publishedYearTo !== undefined) { 
                localVarFormParams.set('publishedYearTo', publishedYearTo as any);
            }
    
            if (numberOfBooksFrom !== undefined) { 
                localVarFormParams.set('numberOfBooksFrom', numberOfBooksFrom as any);
            }
    
            if (numberOfBooksTo !== undefined) { 
                localVarFormParams.set('numberOfBooksTo', numberOfBooksTo as any);
            }
    
            if (yearFrom !== undefined) { 
                localVarFormParams.set('yearFrom', yearFrom as any);
            }
    
            if (yearTo !== undefined) { 
                localVarFormParams.set('yearTo', yearTo as any);
            }
    
            if (miniseries !== undefined) { 
                localVarFormParams.set('miniseries', miniseries as any);
            }
    
            if (eBookSeries !== undefined) { 
                localVarFormParams.set('eBookSeries', eBookSeries as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BookSeriesApi - functional programming interface
 * @export
 */
export const BookSeriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BookSeriesApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrival of a single book series
         * @param {string} uid Book series unique ID
         * @param {string} [apiKey] API key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bookSeriesGet(uid: string, apiKey?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BookSeriesFullResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bookSeriesGet(uid, apiKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Pagination over book series
         * @param {number} [pageNumber] Zero-based page number
         * @param {number} [pageSize] Page size
         * @param {string} [apiKey] API key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bookSeriesSearchGet(pageNumber?: number, pageSize?: number, apiKey?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BookSeriesBaseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bookSeriesSearchGet(pageNumber, pageSize, apiKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Searching book series
         * @param {number} [pageNumber] Zero-based page number
         * @param {number} [pageSize] Page size
         * @param {string} [sort] Sorting, serialized like this: fieldName,ASC;anotherFieldName,DESC
         * @param {string} [apiKey] API key
         * @param {string} [title] Book series title
         * @param {number} [publishedYearFrom] Starting year the book series was published
         * @param {number} [publishedYearTo] Ending year the book series was published
         * @param {number} [numberOfBooksFrom] Minimal number of books
         * @param {number} [numberOfBooksTo] Maximal number of books
         * @param {number} [yearFrom] Starting year of book series stories
         * @param {number} [yearTo] Ending year of book series stories
         * @param {boolean} [miniseries] Whether it should be a miniseries
         * @param {boolean} [eBookSeries] Whether it should be an e-book series
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bookSeriesSearchPost(pageNumber?: number, pageSize?: number, sort?: string, apiKey?: string, title?: string, publishedYearFrom?: number, publishedYearTo?: number, numberOfBooksFrom?: number, numberOfBooksTo?: number, yearFrom?: number, yearTo?: number, miniseries?: boolean, eBookSeries?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BookSeriesBaseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bookSeriesSearchPost(pageNumber, pageSize, sort, apiKey, title, publishedYearFrom, publishedYearTo, numberOfBooksFrom, numberOfBooksTo, yearFrom, yearTo, miniseries, eBookSeries, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BookSeriesApi - factory interface
 * @export
 */
export const BookSeriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BookSeriesApiFp(configuration)
    return {
        /**
         * Retrival of a single book series
         * @param {string} uid Book series unique ID
         * @param {string} [apiKey] API key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookSeriesGet(uid: string, apiKey?: string, options?: any): AxiosPromise<BookSeriesFullResponse> {
            return localVarFp.bookSeriesGet(uid, apiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Pagination over book series
         * @param {number} [pageNumber] Zero-based page number
         * @param {number} [pageSize] Page size
         * @param {string} [apiKey] API key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookSeriesSearchGet(pageNumber?: number, pageSize?: number, apiKey?: string, options?: any): AxiosPromise<BookSeriesBaseResponse> {
            return localVarFp.bookSeriesSearchGet(pageNumber, pageSize, apiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Searching book series
         * @param {number} [pageNumber] Zero-based page number
         * @param {number} [pageSize] Page size
         * @param {string} [sort] Sorting, serialized like this: fieldName,ASC;anotherFieldName,DESC
         * @param {string} [apiKey] API key
         * @param {string} [title] Book series title
         * @param {number} [publishedYearFrom] Starting year the book series was published
         * @param {number} [publishedYearTo] Ending year the book series was published
         * @param {number} [numberOfBooksFrom] Minimal number of books
         * @param {number} [numberOfBooksTo] Maximal number of books
         * @param {number} [yearFrom] Starting year of book series stories
         * @param {number} [yearTo] Ending year of book series stories
         * @param {boolean} [miniseries] Whether it should be a miniseries
         * @param {boolean} [eBookSeries] Whether it should be an e-book series
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookSeriesSearchPost(pageNumber?: number, pageSize?: number, sort?: string, apiKey?: string, title?: string, publishedYearFrom?: number, publishedYearTo?: number, numberOfBooksFrom?: number, numberOfBooksTo?: number, yearFrom?: number, yearTo?: number, miniseries?: boolean, eBookSeries?: boolean, options?: any): AxiosPromise<BookSeriesBaseResponse> {
            return localVarFp.bookSeriesSearchPost(pageNumber, pageSize, sort, apiKey, title, publishedYearFrom, publishedYearTo, numberOfBooksFrom, numberOfBooksTo, yearFrom, yearTo, miniseries, eBookSeries, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BookSeriesApi - object-oriented interface
 * @export
 * @class BookSeriesApi
 * @extends {BaseAPI}
 */
export class BookSeriesApi extends BaseAPI {
    /**
     * Retrival of a single book series
     * @param {string} uid Book series unique ID
     * @param {string} [apiKey] API key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookSeriesApi
     */
    public bookSeriesGet(uid: string, apiKey?: string, options?: AxiosRequestConfig) {
        return BookSeriesApiFp(this.configuration).bookSeriesGet(uid, apiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Pagination over book series
     * @param {number} [pageNumber] Zero-based page number
     * @param {number} [pageSize] Page size
     * @param {string} [apiKey] API key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookSeriesApi
     */
    public bookSeriesSearchGet(pageNumber?: number, pageSize?: number, apiKey?: string, options?: AxiosRequestConfig) {
        return BookSeriesApiFp(this.configuration).bookSeriesSearchGet(pageNumber, pageSize, apiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Searching book series
     * @param {number} [pageNumber] Zero-based page number
     * @param {number} [pageSize] Page size
     * @param {string} [sort] Sorting, serialized like this: fieldName,ASC;anotherFieldName,DESC
     * @param {string} [apiKey] API key
     * @param {string} [title] Book series title
     * @param {number} [publishedYearFrom] Starting year the book series was published
     * @param {number} [publishedYearTo] Ending year the book series was published
     * @param {number} [numberOfBooksFrom] Minimal number of books
     * @param {number} [numberOfBooksTo] Maximal number of books
     * @param {number} [yearFrom] Starting year of book series stories
     * @param {number} [yearTo] Ending year of book series stories
     * @param {boolean} [miniseries] Whether it should be a miniseries
     * @param {boolean} [eBookSeries] Whether it should be an e-book series
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookSeriesApi
     */
    public bookSeriesSearchPost(pageNumber?: number, pageSize?: number, sort?: string, apiKey?: string, title?: string, publishedYearFrom?: number, publishedYearTo?: number, numberOfBooksFrom?: number, numberOfBooksTo?: number, yearFrom?: number, yearTo?: number, miniseries?: boolean, eBookSeries?: boolean, options?: AxiosRequestConfig) {
        return BookSeriesApiFp(this.configuration).bookSeriesSearchPost(pageNumber, pageSize, sort, apiKey, title, publishedYearFrom, publishedYearTo, numberOfBooksFrom, numberOfBooksTo, yearFrom, yearTo, miniseries, eBookSeries, options).then((request) => request(this.axios, this.basePath));
    }
}


